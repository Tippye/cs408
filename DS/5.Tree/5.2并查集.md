# 并差集
并差集的本质是采用双亲表示法的树

| 数据元素 | A | B | C | D | E | F | G | H | I | J | K | L | M |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 数组下标 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 |
| S[] | -1 | 0 | -1 | -1 | 1 | 1 | 2 | 3 | 3 | 3 | 3 | 4 | 4 | 7 |
> 并差集是逻辑结构——集合的一种具体实现，只进行“并”和“查”两种基本操作
> 具体代码实现可以参考[5.5查并集.cpp](./5.5查并集.cpp)

- 查找的最坏时间复杂度为`O(n)`(高度 h=结点数 n 时)
- 合并的时间复杂度为`O(1)`
## 优化并差集合并操作
实际是通过优化合并操作来优化查找的时间复杂度
树越高查找的时间越长，所以通过优化合并的操作来让树尽可能的矮
现在所有根结点的值都是 -1，可以利用根结点的值附带上集合结点数量信息，每次合并都让小树合并到大树上
下面表格是优化后的并差集，0 号位置的`-6`表示`A`为根结点的树的总结点数是 6 个。同理`C`为根结点的树的总结点数是 2 个。

| 数据元素 | A | B | C | D | E | F | G | H | I | J | K | L | M |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 数组下标 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 |
| S[] | **-6** | 0 | **-2** | **-5** | 1 | 1 | 2 | 3 | 3 | 3 | 3 | 4 | 4 | 7 |

优化后的代码可以参考[5.5查并集.cpp](5.5并查集.cpp)中的`BetterUnion`
优化后`Find`的时间复杂度为 O(log<sub>2</sub>n)
此时构造的树高度不超过 (log<sub>2</sub>n)+1