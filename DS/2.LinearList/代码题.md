[TOC]

> 代码运行可以参考根目录下[README.md](../../README.md#程序调试)中的程序调试和[main.cpp](../main.cpp)
>
> 题目标题不能直接跳转，需要把项目拉到本地用编译器打开后才能跳转，或者去仓库里找对应路径的代码文件

# [1.合并有序链表](./2.LinearList/code_question/mergeTwoLists.h)

将两个递增的有序链表合并为一个递增的有序链表。要求结果链表仍使用原来两表的存储空间，不另外占用其他的存储空间。表中不允许有重复的数据。

输入：

```mermaid
graph LR;
A((1))-->B((2))-->C((4))
D((1))-->E((3))-->F((4))
```

输出：

```mermaid
graph LR;
A((1))-->B((2))-->C((3))-->D((4))
```



```c++
ListNode *mergeTwoLists(ListNode *list1, ListNode *list2) {
  // 利用递归进行合并
  
  // 结束条件：其中一个链表为空时不需要合并，直接返回
  if (list1 == NULL) return list1;
  if (list2 == NULL) return list2;
  
  if (list1->val < list2->val) {
    list1->next = mergeTwoLists(list1->next, list2);
    return list1;
  } else if (list1->val > list2->val) {
    list2->next = mergeTwoLists(list1, list2->next);
    return list2;
  } else {
    list1->next = mergeTwoLists(list1->next, list2->next);
    return list1;
  }
}
```



# [2.求两链表交集](./2.LinearList/code_question/getTwoListsDifference.h)

已知两个链表A和B分别表示两个集合，其元素递增排列。请设计一个算法，用于求出A与B的交集，并将结果存放在A链表中。

输入:

```mermaid
graph LR;
A((1))-->B((2))-->C((3))-->D((4))-->E((5))-->F((6))-->G((7))
H((2))-->I((3))-->J((5))-->K((7))
```

输出：

```mermaid
graph LR;
B((2))-->C((3))-->E((5))-->G((7))
```



```c++
ListNode *mixTwoLists(ListNode *A, ListNode *B) {
  ListNode *pa = A->next; // A链表指针
  ListNode *pb = B->next; // B链表指针
  ListNode *pc = A;       // A链表父结点指针

  // 其中一个到结尾时循环停止
  while (pa && pb) {
    if (pa->val == pb->val) {
      // 两个节点相同时，保留A链表中的节点
      pc->next = pa;
      // 保留A链表中的节点后pc指针向后移动
      pc = pa;

      // 因为AB链表两项相同，所以都向后移动一位
      pa = pa->next;
      pb = pb->next;
    } else if (pa->val < pb->val) {
      // 如果A链表的节点比B链表的节点小，就删除A链表中的节点，因为两个链表是按顺序排的，pa后边可能有与pb相同的节点，所以只删除pa
      // 删除方法就是pc的next指向pa的next，这样就会跳过pa
      // pa向后移动一位，pc位置不变，因为pa被删除所以pa向后移动一位后依然是pc的下一位
      pa = pa->next;
      pc->next = pa;
    } else {
      // 如果A链表的节点比B链表的节点大，就删除B链表中的节点，因为两个链表是按顺序排的，pb后边可能有与pa相同的节点，所以只删除pb
      // 删除方法就是pc的next指向pb的next，这样就会跳过pb
      // pb向后移动一位，pc位置不变，因为pb被删除所以pb向后移动一位后依然是pc的下一位
      pb = pb->next;
      pc->next = pb;
    }
  }
  // 循环结束，到这里可能是因为B链表到了结尾，但A链表还没到结尾，所以要把pc后面的节点都删掉，直接让pc的next指向空
  pc->next = nullptr;
  // 被删除的节点和B链表系统会进行回收
  return A;
}
```





# [3.分割链表](./2.LinearList/code_question/splitLinkList.h)

设计算法将一个带头结点的单链表A分解成两个具有相同结构的链表B和链表C，其中B表的节点为A表中值小于0的节点，而C表的节点为A表中值大于0的节点(链表A中的元素为非零整数，要求B、C表利用A表的节点)
```c++
vector<ListNode*> splitListToParts(ListNode* head) {
    // 用来存放结果的两个链表
    vector<ListNode *> result(2, nullptr);
    // head有头结点所以令pa指向head的next
    ListNode *pa = head->next;
    // B、C链表为结果链表
    ListNode *B = new ListNode();
    ListNode *C = new ListNode();
    // 将B、C链表的头结点放到数组中
    result[0] = B;
    result[1] = C;

    // 循环A链表
    while (pa) {
        if (pa->val < 0){
            // 如果pa是负数，就存放到B链表
            B->next = pa;
            B = B->next;
        }else{
            // 如果pa是正数，就存放到C链表
            C->next = pa;
            C = C->next;
        }
        // 存放后让pa指针后移
        pa = pa->next;
    }
    // 将B、C节点的next指向空（下面的测试例子，如果这里不指向空，C会指向A链表的倒数第二项，导致A链表的最后一项也会在C链表中）
    B->next = nullptr;
    C->next = nullptr;
    return result;
}
```

# [4.查找链表最大值](./2.LinearList/code_question/findListMax.h)

设计一个算法，通过一趟遍历确定长度为n的单链表中值最大的节点。

```c++
int findListMax(ListNode *list) {
  // 如果传进来空链表，直接返回空
  if(!list) return NULL;

  // 令max等于list第一项的值，如果没有上一步，这里可能会报空指针错误
  int max = list->val;
  // pa指向list第二个节点
  ListNode* pa = list->next;
  // 循环找最大值
  while (pa){
    // 这一行等价于后面注释的三行，if的三元表达式
    max = max<pa->val?pa->val:max;
    //if (max<pa->val){
    //  max = pa->val;
    //}
    // pa向后移动一位
    pa = pa->next;
  }
  return max;
}
```

```c++
// 递归版本
int findListMax_recursion(ListNode *list) {
  return list ? max(list->val, findListMax_recursion(list->next)) : INT_MIN;
}
```



# [5.反转链表](./2.LinearList/code_question/reverseList.h)

设计一个算法，将链表中所有节点的链接方向“原地”逆转，即要求仅利用原表的存储空间，换句话说，要求算法的空间复杂度为O(1)

```c++
ListNode *reverseList(ListNode *head) {
  ListNode *prev, *curr = head, *next;
  while (curr) {
    // next存放下一个节点，方便修改指针后找到下一个节点
    next = curr->next;
    // 修改curr的next指针指向上一个节点
    curr->next = prev;
    
    // 准备下一次循环，prev和curr都往后移动一位
    prev = curr;
    curr = next;
  }
  // 因为循环最后会把所有指针向后移动一位，所以curr应该是指向空，prev才是新链表的头结点
  return prev;
}
```

